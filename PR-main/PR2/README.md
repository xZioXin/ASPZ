# ЗАВДАННЯ 1

## Умова

Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

## Опис програми

Ця програма досліджує тип даних time_t, який використовується для представлення часу в системах Unix. Вона визначає розмір time_t (у байтах) та його максимальне можливе значення для поточної архітектури (32- або 64-бітної). Далі програма намагається перетворити максимальне значення time_t у читабельний формат дати за допомогою функції ctime().  

**Ключові висновки:**  
- На **32-бітній** архітектурі time_t зазвичай має розмір **4 байти**, а його максимальне значення відповідає **19 січня 2038 року**.  
- На **64-бітній** архітектурі time_t займає **8 байт**, і його максимальне значення настільки велике, що перевищує можливості функції 'ctime()', що призводить до помилки.  

Програма також демонструє, як архітектура системи впливає на представлення часу, і підкреслює важливість використання 64-бітних систем для уникнення обмежень, пов’язаних із 2038 роком.

## [Код до завдання](task2_1/task.c)

![Зображення](task2_1/1.png)

---

# ЗАВДАННЯ 2

## Умова

Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму 'hello world', запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
**Проаналізуйте результати, щоб переконатися, що:**
- сегмент даних зберігається у виконуваному файлі;
- сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);
- текстовий сегмент більшою мірою піддається перевіркам оптимізації;
- на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

## Опис програми
1. **Базовий випадок (task1.c):**  
   - Мінімальний розмір text (код), невеликі data та bss.  
   - Загальний розмір файлу: 15 960 байт.  

2. **Глобальний неініціалізований масив (task2.c):**  
   - Масив розміщується у сегменті bss (не займає місця у файлі, але вимагає пам’яті під час виконання).  
   - bss зростає до 4032 байт.  
   - Загальний розмір файлу залишається майже незмінним.  

3. **Глобальний ініціалізований масив (task3.c):**  
   - Масив переміщується до data (зберігається у файлі).  
   - data зростає до 4616 байт, bss скорочується.  
   - Загальний розмір файлу збільшується (20 008 байт).  

4. **Локальні масиви (task4.c):**  
   - Локальні масиви (ініціалізований та ні) не впливають на розмір виконуваного файлу, оскільки виділяються на стеку під час виконання.  
   - Незначне зростання text через додатковий код ініціалізації.  

### Висновки:  
- **Сегмент data** зберігається у файлі, тому ініціалізовані дані збільшують його розмір.  
- **Сегмент bss** не займає місця у файлі (лише вказує розмір для виділення пам’яті під час запуску).  
- **Текстовий сегмент (text)** змінюється при додаванні коду (наприклад, ініціалізації), але оптимізація може його скоротити.  
- Налагоджувальні збірки збільшують розмір файлу через додаткову інформацію, але не впливають на data/bss.
## [Код до завдання(task1.c)](task2_2/task1.c)
## [Код до завдання(task2.c)](task2_2/task2.c)
## [Код до завдання(task3.c)](task2_2/task3.c)
## [Код до завдання(task4.c)](task2_2/task4.c)

![Зображення](task2_2/2_1.png)
![Зображення](task2_2/2_2.png)

---

# ЗАВДАННЯ ЗА ВАРІАНТОМ

## Умова

Реалізуйте програму, яка зчитує з файлу текст та визначає частоту кожного символу. Виведіть символи у порядку спадання їх частоти.

## Опис програми

Ця програма зчитує вміст файлу `input.txt` та визначає частоту кожного символу в цьому файлі. Для цього вона використовує масив для підрахунку кількості входжень кожного символу (з урахуванням ASCII-кодів). Після зчитування даних програма формує таблицю символів та їх частот, яка потім сортується у порядку спадання частоти. Результат виводиться у вигляді таблиці, де для кожного символу вказана його частота. Спеціальні символи (наприклад, перенос рядка, табуляція, пробіл) відображаються у зручному для читання форматі. Таким чином, програма надає статистику використання символів у файлі, впорядковану за частотою.

## [Код до завдання](task.c)

![Зображення](19.png)

---
